#include <stdio.h>
#include <ros/ros.h>
#include <pluginlib/class_list_macros.h>
#include <nodelet/nodelet.h>

#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud.h>
#include <pcl/PCLPointCloud2.h>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <pcl/conversions.h>

#include <pcl_conversions/pcl_conversions.h>
#include <pcl/conversions.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl_ros/filters/filter.h>

#include "akira_recog_obj/akira_recog_obj.h"

#define THRESHOLD 0.01

namespace akira_recog_obj
{
  recogObjMainClass::recogObjMainClass ()
  {
    ROS_INFO ( "akira_recog_obj nodelet start" );
  }

  recogObjMainClass::~recogObjMainClass ()
  {
    ROS_INFO ( "akira_recog_obj nodelet stop" );
  }

  ros::Publisher pub;
  ros::Subscriber sub;

  void recogObjMainClass::onInit ()
  {
    ros::NodeHandle& nh = getNodeHandle ();
    pub = nh.advertise <sensor_msgs::PointCloud2> ( "out" , 1 );
    sub = nh.subscribe ( "/camera/depth_registered/points", 10, &recogObjMainClass::callback, this );
  }
  
  void recogObjMainClass::callback ( const sensor_msgs::PointCloud2::ConstPtr& input )
  {
    pcl::PCLPointCloud2::Ptr raw_cloud ( new pcl::PCLPointCloud2 );
    pcl::PCLPointCloud2ConstPtr raw_cloudPtr ( raw_cloud );
    pcl::PCLPointCloud2 raw_cloud_filtered;//消すとコアダンプ起きる
    pcl_conversions::toPCL ( *input, *raw_cloud );
    pcl::VoxelGrid<pcl::PCLPointCloud2> sor;
    sor.setInputCloud ( raw_cloudPtr );
    sor.setLeafSize ( 0.05, 0.05, 0.05 );
    sor.filter ( raw_cloud_filtered );

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr voxeled_cloud ( new pcl::PointCloud<pcl::PointXYZRGB> );
    pcl::fromPCLPointCloud2 ( raw_cloud_filtered, *voxeled_cloud );
    pcl::ModelCoefficients::Ptr coefficients ( new pcl::ModelCoefficients );
    pcl::PointIndices::Ptr inliers ( new pcl::PointIndices );

    pcl::SACSegmentation <pcl::PointXYZRGB> seg;
    seg.setOptimizeCoefficients ( true );
    seg.setModelType ( pcl::SACMODEL_PLANE );
    seg.setMethodType ( pcl::SAC_RANSAC );
    seg.setDistanceThreshold ( THRESHOLD );
    seg.setInputCloud ( voxeled_cloud->makeShared () );
    seg.segment ( *inliers, *coefficients );

    pcl_msgs::ModelCoefficients::Ptr ros_coefficients ( new pcl_msgs::ModelCoefficients );
    pcl_conversions::fromPCL ( *coefficients, *ros_coefficients );

    if ( inliers->indices.size () == 0 )
      {
	ROS_INFO ( "no inliers" );
      }
    else
      {
	/*****
	for ( size_t i = 0 ; i < inliers->indices.size () ; i++ )
	  {
	    voxeled_cloud->points[ inliers->indices[ i ] ].r = 255;
	    voxeled_cloud->points[ inliers->indices[ i ] ].g = 0;
	    voxeled_cloud->points[ inliers->indices[ i ] ].b = 0;
	  }
	*****/
	for ( size_t i = 0 ; i < voxeled_cloud->points.size () ; i++ )
	  {
	    for ( size_t j = 0 ; j < inliers->indices.size () ; j++ )
	      {
		if ( (int)i == (int)inliers->indices[ j ] )
		  {
		    voxeled_cloud->points[ i ].r = 255;
		    voxeled_cloud->points[ i ].g = 0;
		    voxeled_cloud->points[ i ].b = 0;
		  }
		else
		  {
		    voxeled_cloud->points[ i ].r = 0;
		    voxeled_cloud->points[ i ].g = 255;
		    voxeled_cloud->points[ i ].b = 0;
		  }
	      }
	  }
      }
    sensor_msgs::PointCloud2::Ptr output ( new sensor_msgs::PointCloud2 );
    pcl::toROSMsg ( *voxeled_cloud, *output );
    pub.publish ( *output );

  }
}

PLUGINLIB_EXPORT_CLASS ( akira_recog_obj::recogObjMainClass, nodelet::Nodelet )

//"nodelet/Tutorials/Porting nodes to nodelets"の差分
//2015年以降は PLUGINLIB_DECLARE_CLASS の代わりに PLUGINLIB_EXPORT_CLASS が採用されている
//http://wiki.ros.org/nodelet/Tutorials/Porting%20nodes%20to%20nodelets?action=diff&rev1=17&rev2=18
//  PLUGINLIB_DECLARE_CLASS ( akira_recog_obj, recogObjMainClass, akira_recog_obj::recogObjMainClass, nodelet::Nodelet );
//
//  PLUGINLIB_EXPORT_CLASS ( PLUGIN_PACKAGE_NAME::PLUGIN_CLASS_NAME, BASE_PACKAGE_NAME::BASE_CLASS_NAME )
//多分，PLUGIN_PACKAGE_NAME は PLUGIN_CLASS_NAME の存在する名前空間

//pcl::PointIndices::indicesはstd::vector<int>だから
//sizeでベクトルのサイズを参照できる
//多分inliersに入ってるのは，inliersであると判断された点の順番

//pcl::toROSMsg ( *cloud, *output );は，
//pcl::PCLPointCloud2::Ptr pcl_output ( new pcl::PCLPointCloud2 );
//pcl::toPCLPointCLoud2 ( *cloud, *pcl_output );
//pcl_conversions::fromPCL ( *pcl_output, *output );
//と同じ．

//動くけど点多すぎでループが終わらん
//voxelgridがあれば大丈夫
//	for ( size_t i = 0 ; i < cloud->points.size () ; i++ )
//	  {
//	    for ( size_t j = 0 ; j < inliers->indices.size () ; j++ )
//	      {
//		if ( i == inliers->indices[ i ] )
//		  {
//		    cloud->points[ inliers->indices[ i ] ].r = 255;
//		    cloud->points[ inliers->indices[ i ] ].g = 0;
//		    cloud->points[ inliers->indices[ i ] ].b = 0;
//		  }
//	      }
//	    printf ( "cloud num: %zu\n", i );
//	  }

//
//
//    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud ( new pcl::PointCloud<pcl::PointXYZRGB> );
//    pcl::fromROSMsg ( *input, *cloud );
//    pcl::ModelCoefficients::Ptr coefficients ( new pcl::ModelCoefficients );
//    pcl::PointIndices::Ptr inliers ( new pcl::PointIndices );
//
//    pcl::SACSegmentation <pcl::PointXYZRGB> seg;
//    seg.setOptimizeCoefficients ( true );
//    seg.setModelType ( pcl::SACMODEL_PLANE );
//    seg.setMethodType ( pcl::SAC_RANSAC );
//    seg.setDistanceThreshold ( THRESHOLD );
//    seg.setInputCloud ( cloud->makeShared () );
//    seg.segment ( *inliers, *coefficients );
//
//    pcl_msgs::ModelCoefficients::Ptr ros_coefficients ( new pcl_msgs::ModelCoefficients );
//    pcl_conversions::fromPCL ( *coefficients, *ros_coefficients );
//
//
//    if ( inliers->indices.size () == 0 )
//      {
//	ROS_INFO ( "no inliers" );
//      }
//    else
//      {
//	for ( size_t i = 0 ; i < inliers->indices.size () ; i++ )
//	  {
//	    cloud->points[ inliers->indices[ i ] ].r = 255;
//	    cloud->points[ inliers->indices[ i ] ].g = 0;
//	    cloud->points[ inliers->indices[ i ] ].b = 0;
//	    printf ( "inlier num: %zu\n", i );
//	  }
//
//      }
//
//    sensor_msgs::PointCloud2::Ptr output ( new sensor_msgs::PointCloud2 );
//    pcl::toROSMsg ( *cloud, *output );
//    pub.publish ( *output );
//
//
